#include "Core/Python.hh"
#include <pybind11/embed.h> //for scoped_interpreter
#include "Units/Units.hh"
#include <iostream>
#include <sstream>
#include <cstdlib>

int main()
{
  py::scoped_interpreter guard{};

  auto py_Path = pyextra::pyimport("pathlib").attr("Path");
  auto py_unitshh = py_Path( std::getenv( "SBLD_INCLUDE_DIR" ) ).attr("joinpath")( "Units", "Units.hh" );
  auto py_hashlib = pyextra::pyimport("hashlib");
  std::string cppheader_md5 = py_hashlib.attr("md5")( py_unitshh.attr("read_bytes")() ).attr("hexdigest")().cast<std::string>();

  py::object py_builtins = py::module_::import("builtins");
  py::object py_float_fromhex = py_builtins.attr("float").attr("fromhex");
  py::object py_repr = py_builtins.attr("repr");

  auto formatvalue = [&py_float_fromhex,&py_repr]( double x )
  {
    //Transfer value in hexfloat format to python side, so we can use
    //repr(floatval).
    std::ostringstream ss;
    ss << std::hexfloat << x;
    auto pyval = py_float_fromhex( py::str( ss.str() ) );
    return py_repr(pyval).cast<std::string>();
  };

#define EXPORTVAR(thenamespace,x) os << "    " << sbld_stringify(x) << " = "<< formatvalue( thenamespace :: x ) <<"\n"
  auto& os = std::cout;
  os << "\"\"\"\n";
  os << "\n";
  os << "Python module providing the same constants and unit conversion values as in the\n";
  os << "corresponding Units.hh C++ header. Please refer to that header file for\n";
  os << "documentation of all values.\n";
  os << "\n";
  os << "\"\"\"\n";
  os << "\n";
  os << "# This file was autogenerated from a C++ header file with an md5sum\n";
  os << "# checksum: "<<cppheader_md5<<"\n";
  os << "\n";
  os << "__all__ = ['units','constants']\n";
  os << "\n";
  os << "class _Units:\n\n";
  EXPORTVAR( NewUnits, deg );
  EXPORTVAR( NewUnits, angstrom );
  EXPORTVAR( NewUnits, nm );
  EXPORTVAR( NewUnits, um );
  EXPORTVAR( NewUnits, mm );
  EXPORTVAR( NewUnits, cm );
  EXPORTVAR( NewUnits, meter );
  EXPORTVAR( NewUnits, m );
  EXPORTVAR( NewUnits, cm2 );
  EXPORTVAR( NewUnits, cm3 );
  EXPORTVAR( NewUnits, m2 );
  EXPORTVAR( NewUnits, m3 );
  EXPORTVAR( NewUnits, second );
  EXPORTVAR( NewUnits, ms );
  EXPORTVAR( NewUnits, millisecond );
  EXPORTVAR( NewUnits, ns );
  EXPORTVAR( NewUnits, nanosecond );
  EXPORTVAR( NewUnits, meV );
  EXPORTVAR( NewUnits, eV );
  EXPORTVAR( NewUnits, keV );
  EXPORTVAR( NewUnits, MeV );
  EXPORTVAR( NewUnits, GeV );
  EXPORTVAR( NewUnits, TeV );
  EXPORTVAR( NewUnits, joule );
  EXPORTVAR( NewUnits, tesla );
  EXPORTVAR( NewUnits, newton );
  EXPORTVAR( NewUnits, pascal );
  EXPORTVAR( NewUnits, bar );
  EXPORTVAR( NewUnits, atmosphere );
  EXPORTVAR( NewUnits, atm );
  EXPORTVAR( NewUnits, coulomb );
  EXPORTVAR( NewUnits, kilogram );
  EXPORTVAR( NewUnits, gram );
  EXPORTVAR( NewUnits, g );
  EXPORTVAR( NewUnits, kelvin );
  EXPORTVAR( NewUnits, mole );
  os << "\n    def __setattr__(self,name,value):\n";
  os << "        raise AttributeError('Units are read-only ')\n";
  os << "    def __delattr__(self,name,value):\n";
  os << "        raise AttributeError('Units are read-only ')\n";
  os << "\n";
  os << "class _Constants:\n\n";
  EXPORTVAR( NewConstants, pi );
  EXPORTVAR( NewConstants, c_light );
  EXPORTVAR( NewConstants, c_squared );
  EXPORTVAR( NewConstants, atomic_unit_of_charge );
  EXPORTVAR( NewConstants, avogadro );
  EXPORTVAR( NewConstants, h_Planck );
  EXPORTVAR( NewConstants, k_Boltzmann );
  EXPORTVAR( NewConstants, neutron_mass_c2 );
  os << "\n    def __setattr__(self,name,value):\n";
  os << "        raise AttributeError('Constants are read-only ')\n";
  os << "    def __delattr__(self,name,value):\n";
  os << "        raise AttributeError('Constants are read-only ')\n";
  os << "\n";
  os << "units = _Units()\n";
  os << "constants = _Constants()\n";
}
